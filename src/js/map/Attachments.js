class Attachments {
    constructor(editor, map) {
        this._editor = editor;
        this._map = map;

        this.selectedThing = null;
        this.attachments = null;

        this.attachmentTypes = [
            { name: 'note', labelSingular: 'Note', labelPlural: 'Notes' },
            { name: 'link', labelSingular: 'Web Link', labelPlural: 'Web Links' },
            { name: 'task', labelSingular: 'Task', labelPlural: 'Tasks' },
            { name: 'map', labelSingular: 'Linked MetaMap', labelPlural: 'Linked MetaMaps' }
            //{name: 'doc', labelSingular: 'Document', labelPlural: 'Documents'}  // limit overall storage space OR simpler rules?
            // limit file types - pdf, jpg, gif, png, office?...  whitelist vs. blacklist
        ];
    }

    handleDiagramEvent(eventName, e) {
        if (eventName === 'ChangedSelection') {
            if (this._map.getUi().currentTabIs(this._map.getUi().TAB_ID_ATTACHMENTS)) {
                this.stopEditingAll();
                this.saveAttachments();
                this.loadSelectedThingAttachments();
            }
        }
    }

    // called when a tab is opened or closed
    currentTabChanged(newValue, oldValue) {
        if (newValue === this._map.getUi().TAB_ID_ATTACHMENTS) { // opening tab
            this.loadSelectedThingAttachments();
        }
        if (oldValue === this._map.getUi().TAB_ID_ATTACHMENTS) { // closing tab
            this.saveAttachments();
        }
    }

    loadSelectedThingAttachments() {
        if (this._map.thingSelected()) {
            this.selectedThing = this._map.getUniqueThingSelected();
            this.attachments = this.selectedThing.data.attachments;
            if (this.attachments === undefined) {
                this.attachments = [];
            }
        }
    }

    // set all attachments to editing = false
    stopEditingAll() {
        if (this.attachments) {
            _.each(this.attachments, (att) => { att.editing = false; });
        }
    }

    editingAnItem() {
        return this.attachments && _.findWhere(this.attachments, { editing: true }) !== undefined;
    }

    // set all other attachments to editing = false
    startEditing(attachment) {
        this.stopEditingAll();
        attachment.editing = true;
    }

    saveItem(attachment) {
        attachment.editing = false;
        this.saveAttachments();
    }

    saveAttachments() {
        console.log('saveAttachments, selected: ' + this.selectedThing);
        if (this.selectedThing) {
            this._map.getDiagram().model.setDataProperty(this.selectedThing.data, 'attachments', this.attachments);
            this.selectedThing.updateTargetBindings();
        }
        this._map.getAutosave().saveNow('edit_attachments');
    }

    listAttachments(type) {
        let atts = _.where(this.attachments, { type: type });
        return atts;
    }

    addAttachment(type) {
        let item = { type: type, editing: true };
        if (type === 'note') {
            this.attachments.push(_.extend(item, { text: '', url: '' }));
        }
        else if (type === 'link') {
            this.attachments.push(_.extend(item, { label: '', url: '' }));
        }
        else if (type === 'task') {
            this.attachments.push(_.extend(item, { text: '' }));
        }
        else if (type === 'doc') {
            this.attachments.push(_.extend(item, { name: '' }));
        }
        else if (type === 'map') {
            this.attachments.push(_.extend(item, { mapRef: { id: 0, name: '' } }));
        }
    }

    isValid(attachment) {
        if (attachment.type === 'link') {
            return attachment.label && attachment.url && attachment.label.trim() !== '' && attachment.url.trim() !== '';
        }
        else if (attachment.type === 'note') {
            return attachment.text && attachment.text.trim() !== '';
        }
        else if (attachment.type === 'task') {
            return attachment.text && attachment.text.trim() !== '';
        }
        else if (attachment.type === 'doc') {
            return attachment.name && attachment.name.trim() !== '';
        }
        else if (attachment.type === 'map') {
            return attachment.mapRef && attachment.mapRef.id !== null && attachment.mapRef.id !== undefined;
        }
    }

    deleteAttachment(att) {
        let typeLabel = _.findWhere(this.attachmentTypes, { name: att.type }).labelSingular;
        if (confirm('Delete ' + typeLabel + '?')) {
            let i = _.indexOf(this.attachments, att);
            this.attachments.splice(i, 1);
        }
    }

    // query server for maps containing the given text in the map name
    getOtherMaps(viewValue) {
        // NB: this URL is constructed to match the one generated by the search form on the maps page...
        let url = '/maps/visible_maps.json?utf8=%E2%9C%93&q%5Bname_cont%5D=' + viewValue;
        return $http.get(url).then((response) => {
            return response.data.maps;
        });
    }

    otherMapSelected(viewValue, modelValue) {
        console.log('otherMapSelected, viewValue: ' + viewValue.id + ', modelValue: ' + modelValue);
    }

    formatOtherMap(model) {
        return (model ? model.name : '');
    }
}

module.exports = Attachments;